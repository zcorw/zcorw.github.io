# TCP、http、Socket
> 身处互联网行业，在日常工作中 TCP、http、Socket 这三个词必不少见，但这三者之间的关系以及他们各自含义不一定从业者都了解。我在这里就对这三者关系简单梳理一下

## 三者关系

在这之前要先提一下 TCP/IP 协议。我们在日常使用互联网产品时，此端与彼端通讯时，用到的通讯协议基本上都是 TCP/IP 协议，它是指利用 IP 进行通信时所必须用到的协议群的统称，并不是某个单一的协议或者 TCP 和 IP 的合称。为了更好理解 TCP/IP 中各种协议的作用，我们对其分成5层：硬件，网卡层，互联网层，传输层，应用层。IP\TCP\http 分别归属于 TCP/IP 中的互联网层、传输层、应用层。

![osi and tcp/ip](https://i.postimg.cc/XqDLhtF2/tcpip.png "OSI参考模型与TCP/IP的关系")

> 来源《图解TCP/IP》插图

在这稍微展开说明各层的作用。

* 硬件和网卡层：就是指光纤、电话线路等物理设备以及他们对应的驱动程序。这部分在日常工作中感知比较少。
* 互联网层：将数据传输到目标地址，IP 地址便是数据传输期间的主机在互联网中主机的标识，IP 也标识要采用哪一个传输层协议。同时 IP 协议让我们在日常编写代码时不用去关心我这些数据要走过多少路由器。另外还有 ICMP，消息无法到达接收方时给发送方发送一个异常通知；ARP，用于解析物理地址的协议。
* 传输层：通信两端主机的传输协议，规定了数据传输的规则，也规定了数据最终要给哪个应用程序。TCP/IP 协议中最具代表的两个协议就是 TCP 和 UDP。
* 应用层：我们日常使用的浏览器可以说是在web应用场景中应用层最经典的代表了，它通过 http 协议解析从服务端发送过来的数据，用html文件将数据表现给我们看。

前面提到了 IP\TCP\http，但文章标题中还有一个 Socket 却一直没有提到，它又是在哪个位置呢？

在解释 TCP/IP 协议时提到的那些名词都是协议，是网络通讯中数据处理的一种标准，而Socket则是操作系统提供的类库，也就是 API，应用程序在使用 TCP 或 UDP 时利用 Socket，可以设置对端的 IP 地址、端口号，并实现数据的发送与接收。

---

另外提一个名词 websocket，虽然它里面也有 socket，但它与 Socket 却没有任何血缘关系，与 http 更接近。websocket 是为了解决 http 协议服务端无法主动向客户端推送消息的问题，目前所有的浏览器都已支持该协议

---

## TCP
前面提到 IP 在通讯中帮助我们定位连接另一端主机的位置，虽然它帮我们将数据传输给对方主机，但它不会去管数据是否有被对方接收，也就是丢包问题它不管，所以这里就需要 TCP 来保证数据通信的完整性和可靠性，防止丢包。同时在 TCP 数据包首部有一个编号，用于识别该数据应该投递给哪个应用处理，这个编号便是端口号。

### 序列号与确认应答
为了确保数据发送主机有到达接收主机，接收主机要返回一个已收到的通知，这个消息就叫做确认应答（ACK）。如果发送主机在一段时间内没有接收到接收主机发送的 ACK，就可以认为数据没有到达接收主机，这时发送主机可以重发数据避免丢包。

在实际应用中，因网络拥堵等情况，也有可能接收主机接收到了数据，但发送的 ACK 并没有到达发送主机，发送主机会不断的重发这段数据，于是接收主机会反复接收到相同数据。为区分哪些接收到的哪些数据是重复内容，就需要一个标识，这个标识就是序列号。

序列号是按顺序给发送数据的每一个字节都标上号码的编号（初始值是建立连接时由主机随机生成的一个数，后面每一个字节就加一）。接收主机查询接收数据 TCP 首部中序列号和数据长度，将自己下一步应该接收的序号作为确认应答返送回去。例如发送主机发送一段序号为1，长度为1000的数据，接收主机在接收到这段数据后发送一条确认应答号为1001的 ACK，告知发送主机接下来发送的数据要从1001位置开始。通过序列号和确认应答号，TCP 就能够保证在不稳定的网络环境中实现可靠的传输。

---

为什么要通过给每个字节编号来作为每次通讯的序号，我想应该是和 MSS（报文最大长度）有关。在通讯中，每次发送的数据包长度是有限的，我们有时要发送一个超大的文件，就不得不根据 MSS 将其分割成多份多次发送。通过确认应答号，发送主机就能清晰的知道哪些部分已经被接收端接收，哪些还没发送。

---

### 三次握手、四次挥手
![tcp connect](https://i.postimg.cc/gJJgLPZ4/1215110-20180201220928796-1989421651.png "三次握手和四次挥手")

> 来源https://blog.csdn.net/qq_28657577/article/details/82631359

TCP 是有连接的通讯协议，在数据通信之前，要先建立一个连接。建立一个 TCP 连接时，需要客户端和服务器总共发送3个包，这就是三次握手。

三次握手可以分为这三步：

* 客户端（在 TCP 连接中首先发起 SYN 包的就称为客户端）发送一个 SYN 包作为建立连接的请求等待确认应答，进入 `SYN_SEND` 状态，表示数据等待发送；（客户端：对面的把瓜放下，我有话要说）
* 服务端（在 TCP 连接中第一个接收 SYN 包的就称为服务端）返回一个包，这个包既有 SYN 标记也有 ACK 标记，进入 `SYN_RCVD` 状态，表示已经知道客户端连接请求并准备好接收，然后等待客户端确认应答；（服务端：瓜放下了，耳朵也准备好了，等你说话）
* 客户端直接返回 ACK 包，发送完成后客户端进入 `ESTABLISHED` 状态，当服务端接收到这个包时，也进入 `ESTABLISHED` 状态，表示双方已经进入连接状态，可以开始正文。（客户端：好的，那我就要开始讲了）

至此三次握手结束，开始发送正式数据。在三次握手中除了确保正式发送前连接正常，同时也确认连接服务器的指定端口，本次通讯双方的序列号，TCP 窗口大小信息，计算MSS等。

要断开一个 TCP 连接，客户端和服务端则要发送4个包，也就是四次挥手。

四次挥手可以分为这四步：（中断请求可以由客户端发起也可以由服务端发起，下面假设是客户端发起）

* 客户端想要关闭连接，首先发起一个 FIN 包，进入 `FIN_WAIT_1` 状态，表示已经没有数据发送，但仍可以接收数据，并等待确认应答；（客户端：我话已说尽，但我仍想听你说说）
* 服务端收到 FIN 包后返回一个 ACK 包，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2` 状态，表示服务端确认客户端要关闭连接的请求，但自己仍有数据未发送；（服务端：我知道你无话可说了，但我还有几点要说下。客户端：行，你说，我在听）
* 服务端准备好关闭连接时，向客户端发送一个 FIN 包，进入 `LAST_ACK` 状态，表示服务端已经准备好关闭连接，等待确认答应；（服务端：我想说的说完了，你没有要说的话我就做别的事了）
* 客户端收到 FIN 包后返回一个 ACK 包，并进入 `TIME_WAIT` 状态，等待可能出现的要求重传的 ACK 包。  
  服务端收到 ACK 包后关闭连接，进入 `CLOSE` 状态。  
  客户端在等待一个固定时间后没有收到服务端的 ACK，也进入 `CLOSE` 状态。
  
至此整个 TCP 连接结束。

### 在 nodejs 中建立 TCP 连接
在 nodejs 中我们可以很容易的建立一个 TCP 连接，net.Socket 类帮我们做了 TCP 或 UNIX Socket 的抽象。

> 参考链接：[https://imweb.io/topic/5963a4c19b7a478b1c268ded](https://imweb.io/topic/5963a4c19b7a478b1c268ded)

### 扩展知识
* SYN攻击
* 窗口滑动
* TCP KeepAlive

## http
http 协议是 web 应用中最常使用的协议，不管是网页访问还是 app 与服务器接口访问都是使用 http 协议。

目前应用最流行的是 HTTP/1.1 版本，它要求发出的请求信息要包括以下几个：

* 请求行（例如GET /images/logo.gif HTTP/1.1）
* 请求头（例如Accept-Language: en）
* 空行 (\r\n)
* 其他消息体

### 请求行
web 前端开发的小伙伴在用 ajax 时一定经常用到 `GET` 和 `POST` 两种方法请求数据，除了这两种方法，HTTP/1.1 还定义了其他六种方法： `HEAD`, `PUT`, `DETELE`, `TRACE`, `OPTIONS`, `CONNECT`。HTTP 服务器至少应该实现 GET 和 HEAD 方法，其他方法都是可选的。

/images/logo.gif 是要获取的资源的路径，通常是上下文中就很明显的元素资源的 URL。在实际应用中，不同的服务器使用不同的框架会运用不一样的路由来实现资源的寻找，这里就不多展开。

### 请求头
请求头中蕴含了希望向服务端传递的一些信息，具体请求头中有哪些可选项可参考下面链接：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)。在这里简单拿几个常用到的字段来说明请求头的作用。

* Host  
  这是 HTTP/1.1 规定必带的一个字段。众所周知，一台服务器可能运行着 N 个网站，就需要这个字段来区分访问的是哪个网站。
* Content-Type  
  指示服务器文档的MIME 类型。HTTP/1.1 允许头信息后面的数据可以是任何格式，就需要这个字段帮助用户代理（浏览器）去处理接收到的数据，我们常见的网页对应值就是 text/html。客户端可以在请求头中带 `Accept` 字段声明自己可以接受哪些格式数据。
* Cookie\Set-Cookie  
  Cookie 是 Web 开发中是十分重要的角色，这两个字段协助 Cookie 的值在客户端和服务端间传递。服务端在请求头中带 `Set-Cookie` 字段，客户端在接收到该字段时将对应值存到浏览器的 cookie 中。当浏览器设置中 cookie 被允许时，cookie 的值在每次请求中都会附在 `Cookie` 字段上被带到服务端。两个字段值格式都是 name=value，如果存在多个值，用分号和一个空格分隔开。

### 其他消息体
这部分就比较自由，根据Content-Type的类型决定消息体的格式。比如Content-Type是 text/html，那这部分数据就应该是一段 html 格式的字符串，如果是 application/json，那可能是请求服务端接口的请求值或从服务端返回的返回值。

### 在 nodejs 中建立 http 服务器
在nodejs中使用http.createServer方法便能简单的创建一个 http 服务器。
> 参考链接：[https://github.com/zcorw/StaticServer](https://github.com/zcorw/StaticServer)

### 在浏览器中设置一次请求的请求头
> 参考链接：[https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/setRequestHeader](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/setRequestHeader)

### 扩展知识
* 跨域访问（CORS）
* HTTP 缓存
* HTTP/2
* HTTP 与 WebSocket 的连接机制
